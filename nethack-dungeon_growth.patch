diff -ruN nethack-3.4.0.orig/include/config.h nethack-3.4.0/include/config.h
--- nethack-3.4.0.orig/include/config.h	Sat Apr 13 18:02:50 2002
+++ nethack-3.4.0/include/config.h	Sat Apr 13 18:08:01 2002
@@ -348,6 +348,7 @@
  * bugs left here.
  */
 
+#define DUNGEON_GROWTH	/* dungeon growth patch */
 #define FLIPCOIN	/* flipcoin patch */
 #define STICKY_OBJECTS	/* sticky objects patch */
 #define DUMP_LOG	/* dump log patch */                                    
diff -ruN nethack-3.4.0.orig/include/extern.h nethack-3.4.0/include/extern.h
--- nethack-3.4.0.orig/include/extern.h	Sat Apr 13 18:02:50 2002
+++ nethack-3.4.0/include/extern.h	Sat Apr 13 18:07:15 2002
@@ -665,6 +665,10 @@
 
 /* ### hack.c ### */
 
+#ifdef DUNGEON_GROWTH
+E void FDECL(catchup_dgn_growths, (int));
+E void FDECL(dgn_growths, (BOOLEAN_P,BOOLEAN_P));
+#endif
 E boolean FDECL(revive_nasty, (int,int,const char*));
 E void FDECL(movobj, (struct obj *,XCHAR_P,XCHAR_P));
 E boolean FDECL(may_dig, (XCHAR_P,XCHAR_P));
diff -ruN nethack-3.4.0.orig/src/allmain.c nethack-3.4.0/src/allmain.c
--- nethack-3.4.0.orig/src/allmain.c	Thu Apr 11 17:58:27 2002
+++ nethack-3.4.0/src/allmain.c	Sat Apr 13 18:07:15 2002
@@ -142,7 +142,9 @@
 		    if(Glib) glibr();
 		    nh_timeout();
 		    run_regions();
-
+#ifdef DUNGEON_GROWTH
+		    dgn_growths(TRUE, TRUE);
+#endif
 		    if (u.ublesscnt)  u.ublesscnt--;
 		    if(flags.time && !flags.run)
 			flags.botl = 1;
diff -ruN nethack-3.4.0.orig/src/hack.c nethack-3.4.0/src/hack.c
--- nethack-3.4.0.orig/src/hack.c	Sat Apr 13 18:02:50 2002
+++ nethack-3.4.0/src/hack.c	Sat Apr 13 18:07:15 2002
@@ -21,6 +21,332 @@
 
 #ifdef OVL2
 
+#ifdef DUNGEON_GROWTH
+void
+rndmappos(x,y) /* guaranteed to return a valid coord */
+xchar *x;
+xchar *y;
+{
+   if (*x >= COLNO) *x = COLNO;
+   else if (*x == -1) *x = rn2(COLNO-1)+1;
+   else if (*x < 1) *x = 1;
+   
+   if (*y >= ROWNO) *y = ROWNO;
+   else if (*y == -1) *y = rn2(ROWNO);
+   else if (*y < 0) *y = 0;
+}
+
+#define HERB_GROWTH_LIMIT    3 /* to limit excessive farming */
+
+static const struct herb_info {
+   int herb;
+   boolean in_water;
+} herb_info[] = { 
+   { SPRIG_OF_WOLFSBANE, FALSE },
+   { CLOVE_OF_GARLIC,    FALSE }, 
+   { CARROT,             FALSE },
+   { KELP_FROND,         TRUE  }
+};
+
+long
+count_herbs_at(x,y, watery)
+xchar x,y;
+boolean watery;
+{
+   register int dd;
+   register long count = 0;
+   
+   if (isok(x,y)) {
+      for (dd = 0; dd < SIZE(herb_info); dd++) {
+	 if (watery == herb_info[dd].in_water) {
+	    register struct obj *otmp = sobj_at(herb_info[dd].herb, x,y);
+	    if (otmp)
+	      count += otmp->quan;
+	 }
+      }
+   }
+   return count;
+}
+
+/* returns TRUE if a herb can grow at (x,y) */
+boolean
+herb_can_grow_at(x,y, watery)
+xchar x,y;
+boolean watery;
+{
+  register struct rm *lev = &levl[x][y];
+  if (inside_shop(x,y)) return FALSE;
+  if (watery) 
+     return (IS_POOL(lev->typ) && 
+	     ((count_herbs_at(x,y, watery)) < HERB_GROWTH_LIMIT));
+   return (lev->lit && (lev->typ == ROOM || lev->typ == CORR ||
+			(IS_DOOR(lev->typ) && 
+			 ((lev->doormask == D_NODOOR) ||
+			 (lev->doormask == D_ISOPEN) ||
+			 (lev->doormask == D_BROKEN)))) &&
+	   (count_herbs_at(x,y, watery) < HERB_GROWTH_LIMIT));
+}
+
+/* grow herbs in water. return true if did something. */
+boolean
+grow_water_herbs(herb, x,y)
+int herb;
+xchar x,y;
+{
+   struct obj *otmp;
+   
+   rndmappos(&x, &y);
+   otmp = sobj_at(herb, x, y);
+   if (otmp && herb_can_grow_at(x,y, TRUE)) {
+      otmp->quan++;
+      otmp->owt = weight(otmp);
+      return TRUE;
+      /* There's no need to start growing these on the neighboring
+       * mapgrids, as they move around (see water_current())
+       */
+   }
+   return FALSE;
+}
+
+/* grow herb on ground at (x,y), or maybe spread out.
+   return true if did something. */
+boolean
+grow_herbs(herb, x,y, showmsg, update)
+int herb;
+xchar x,y;
+boolean showmsg, update;
+{
+   struct obj *otmp;
+   struct rm *lev;
+   
+   rndmappos(&x, &y);
+   lev = &levl[x][y];
+   otmp = sobj_at(herb, x, y);
+   if (otmp && herb_can_grow_at(x,y, FALSE)) {
+      if (otmp->quan <= rn2(HERB_GROWTH_LIMIT)) {
+	 otmp->quan++;
+	 otmp->owt = weight(otmp);
+	 return TRUE;
+      } else {
+	 int dd, dofs = rn2(8);
+	 /* check surroundings, maybe grow there? */
+	 for (dd = 0; dd < 8; dd++) {
+	    coord pos;
+	    
+	    dtoxy(&pos, (dd+dofs) % 8);
+	    pos.x += x;
+	    pos.y += y;
+	    if (isok(pos.x,pos.y) && herb_can_grow_at(pos.x,pos.y, FALSE)) {
+	       lev = &levl[pos.x][pos.y];
+	       otmp = sobj_at(herb, pos.x, pos.y);
+	       if (otmp) {
+		  if (otmp->quan <= rn2(HERB_GROWTH_LIMIT)) {
+		     otmp->quan++;
+		     otmp->owt = weight(otmp);
+		     return TRUE;
+		  }
+	       } else {
+		  otmp = mksobj(herb, TRUE, FALSE);
+		  otmp->quan = 1;
+		  otmp->owt = weight(otmp); 
+		  place_object(otmp, pos.x, pos.y);
+		  if (update) newsym(pos.x,pos.y);
+		  if (cansee(pos.x,pos.y)) {
+		     if (showmsg && flags.verbose) {
+			const char *what;
+			if (herb == CLOVE_OF_GARLIC)
+			  what = "some garlic";
+			else 
+			  what = an(xname(otmp));
+			Norep("Suddenly you notice %s growing on the %s.",
+			      what, surface(pos.x,pos.y));
+		     }
+		  }
+		  return TRUE;
+	       } 
+	    }
+	 }
+      } 
+   }
+   return FALSE;
+}
+
+/* moves topmost object in water at (x,y) to dir. 
+   return true if did something. */
+boolean
+water_current(x,y,dir,waterforce, showmsg, update)
+xchar x,y;
+int dir;
+unsigned waterforce;  /* strength of the water current */
+boolean showmsg, update;
+{
+   struct obj *otmp;
+   coord pos;
+
+   rndmappos(&x,&y);
+   dtoxy(&pos, dir);
+   pos.x += x;
+   pos.y += y;
+   if (isok(pos.x,pos.y) && IS_POOL(levl[x][y].typ) && 
+       IS_POOL(levl[pos.x][pos.y].typ)) {
+      otmp = level.objects[x][y];
+      if (otmp && otmp->where == OBJ_FLOOR) {
+	 if (otmp->quan > 1) 
+	   otmp = splitobj(otmp, otmp->quan - 1);
+	 if (otmp->owt <= waterforce) {
+	    if (showmsg && Underwater && 
+		(cansee(pos.x,pos.y) || cansee(x,y))) {
+	       Norep("%s floats%s in%s the murky water.",
+		     An(xname(otmp)),
+		     (cansee(x,y) && cansee(pos.x,pos.y)) ? "" :
+		     (cansee(x,y) ? " away from you" : " towards you"),
+		     flags.verbose ? " the currents of" : "");
+	    }
+	    obj_extract_self(otmp);
+	    place_object(otmp, pos.x,pos.y);
+	    stackobj(otmp);
+	    if (update) {
+	       newsym(x,y);
+	       newsym(pos.x,pos.y);
+	    }
+	    return TRUE;
+	 } else  /* the object didn't move, put it back */
+	   stackobj(otmp);
+      }
+   }
+   return FALSE;
+}
+
+/* a tree at (x,y) spontaneously drops a ripe fruit */
+boolean
+drop_ripe_treefruit(x,y,showmsg, update)
+xchar x,y;
+boolean showmsg, update;
+{
+   register struct rm *lev;
+   
+   rndmappos(&x,&y);
+   lev = &levl[x][y];
+   if (IS_TREE(lev->typ) && !(lev->looted & TREE_LOOTED)) {
+      coord pos;
+      int dir, dofs = rn2(8);
+      for (dir = 0; dir < 8; dir++) {
+	 dtoxy(&pos, (dir + dofs) % 8);
+	 pos.x += x;
+	 pos.y += y;
+	 lev = &levl[pos.x][pos.y];
+	 if (SPACE_POS(lev->typ) || IS_POOL(lev->typ)) {
+	    struct obj *otmp;
+	    otmp = rnd_treefruit_at(pos.x,pos.y);
+	    if (otmp) {
+	       otmp->quan = 1;
+	       otmp->owt = weight(otmp);
+	       obj_extract_self(otmp);
+	       if (rn2(3))
+		 otmp->orotten = TRUE; /* Blecch!  Rotten food! */
+	       if (showmsg) {
+		  if ((cansee(pos.x,pos.y) || cansee(x,y))) {
+		     Norep("%s falls from %s%s.",
+			   cansee(pos.x,pos.y) ? An(xname(otmp)) : Something,
+			   cansee(x,y) ? "the tree" : "somewhere",
+			   (cansee(x,y) && IS_POOL(lev->typ)) ? 
+			   " into the water" : "");
+		  } else if (distu(pos.x,pos.y) < 9 && 
+			     otmp->otyp != EUCALYPTUS_LEAF) {
+		     /* a leaf is too light to cause any sound */
+		     You_hear("a %s!",
+			      (IS_POOL(lev->typ) || IS_FOUNTAIN(lev->typ)) ? 
+			      "plop" : "splut"); /* rainforesty sounds */
+		  }
+	       }
+	       place_object(otmp, pos.x,pos.y);
+	       stackobj(otmp);
+	       if (rn2(6)) levl[x][y].looted |= TREE_LOOTED;
+	       if (update) newsym(pos.x,pos.y);
+	       return TRUE;
+	    }
+	 }
+      }
+   }
+   return FALSE;
+}
+
+/* Tree at (x,y) seeds. returns TRUE if a new tree was created.
+ * Creates a kind of forest, with (hopefully) most places available.
+ */
+boolean
+seed_tree(x,y)
+xchar x,y;
+{
+   coord pos, pos2;
+   struct rm *lev = &levl[pos.x][pos.y];
+   
+   rndmappos(&x,&y);
+   if (IS_TREE(levl[x][y].typ)) {
+      int dir = rn2(8);
+      dtoxy(&pos, dir);
+      pos.x += x;
+      pos.y += y;
+      if (!rn2(3)) {
+	 dtoxy(&pos2, (dir+rn2(2)) % 8);
+	 pos.x += pos2.x;
+	 pos.y += pos2.y;
+      }
+      if (!isok(pos.x,pos.y)) return FALSE;
+      lev = &levl[pos.x][pos.y];
+      if (lev->lit && !cansee(pos.x,pos.y) && !inside_shop(pos.x,pos.y) &&
+	  (lev->typ == ROOM || lev->typ == CORR) &&
+	  !(u.ux == pos.x && u.uy == pos.y) && !m_at(pos.x,pos.y) && 
+	  !t_at(pos.x,pos.y) && !OBJ_AT(pos.x,pos.y)) {
+	 int nogrow = 0;
+	 int dx,dy;
+	 for (dx = pos.x-1; dx <= pos.x+1; dx++) {
+	    for (dy = pos.y-1; dy <= pos.y+1; dy++) {
+	       if (!isok(dx,dy) || 
+		   (isok(dx,dy) && !SPACE_POS(levl[dx][dy].typ)))
+		 nogrow++;
+	    }
+	 }
+	 if (nogrow < 3) {
+	    lev->typ = TREE;
+	    lev->looted &= ~TREE_LOOTED;
+	    block_point(pos.x,pos.y);
+	    return TRUE;
+	 }
+      }
+   } 
+   return FALSE;
+}
+
+void
+dgn_growths(showmsg, update)
+boolean showmsg; /* show messages */
+boolean update;  /* do newsym() */
+{
+   int herbnum = rn2(SIZE(herb_info));
+   (void) seed_tree(-1,-1);
+   if (herb_info[herbnum].in_water)
+     (void) grow_water_herbs(herb_info[herbnum].herb, -1,-1);
+   else
+     (void) grow_herbs(herb_info[herbnum].herb, -1,-1, showmsg, update);
+   if (!rn2(30))
+     (void) drop_ripe_treefruit(-1,-1, showmsg, update);
+   (void) water_current(-1,-1, rn2(8), 
+			Is_waterlevel(&u.uz) ? 200 : 25, showmsg, update);
+}
+
+/* catch up with growths when returning to a previously visited level */
+void
+catchup_dgn_growths(mvs)
+int mvs;
+{
+   if (mvs < 0) mvs = 0;
+   else if (mvs > LARGEST_INT) mvs = LARGEST_INT;
+   while (mvs-- > 0)
+     dgn_growths(FALSE, FALSE);
+}
+#endif /* DUNGEON_GROWTH */
+
 boolean
 revive_nasty(x, y, msg)
 int x,y;
diff -ruN nethack-3.4.0.orig/src/restore.c nethack-3.4.0/src/restore.c
--- nethack-3.4.0.orig/src/restore.c	Thu Apr 11 17:58:28 2002
+++ nethack-3.4.0/src/restore.c	Sat Apr 13 18:07:15 2002
@@ -866,7 +866,9 @@
 	relink_timers(ghostly);
 	relink_light_sources(ghostly);
 	reset_oattached_mids(ghostly);
-
+#ifdef DUNGEON_GROWTH
+	if (!ghostly) catchup_dgn_growths((monstermoves - omoves) / 5);
+#endif
 	if (ghostly)
 	    clear_id_mapping();
 }
