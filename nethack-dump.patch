diff -ruN nethack-3.4.0./dat/opthelp nethack-3.4.0/dat/opthelp
--- nethack-3.4.0./dat/opthelp	Wed Jun 12 00:29:06 2002
+++ nethack-3.4.0/dat/opthelp	Wed Jun 12 00:29:19 2002
@@ -94,6 +94,9 @@
 boulder       override the default boulder symbol with another default:`
 disclose      the types of information you want offered at the end of the
               game  [all]
+dumpfile      the name of the file where to dump the disclosure information
+              when the game ends (only if the patch has been compiled in
+              [none]
 fruit         the name of a fruit you enjoy eating  [slime mold]
               (basically a whimsy which NetHack uses from time to time).
 menustyle     user interface for selection of multiple objects:
diff -ruN nethack-3.4.0./doc/Guidebook.mn nethack-3.4.0/doc/Guidebook.mn
--- nethack-3.4.0./doc/Guidebook.mn	Wed Jun 12 00:29:06 2002
+++ nethack-3.4.0/doc/Guidebook.mn	Wed Jun 12 00:29:19 2002
@@ -1690,6 +1690,12 @@
 .lp dogname
 Name your starting dog (ex. ``dogname:Fang'').
 Cannot be set with the `O' command.
+.lp dumpfile
+The name of a file where the disclosure information is written when the 
+game ends. You may use the macro %n that will be replaced with the name 
+of your player character. The game must have write permissions to the 
+directory where the file is written. Normally /tmp may be used for unix 
+systems.
 .lp dungeon
 Set the graphics symbols for displaying the dungeon
 (default \&``\ |--------||.-|++##.##<><>_|\e\e#{}.}..##\ #}'').
diff -ruN nethack-3.4.0./doc/Guidebook.tex nethack-3.4.0/doc/Guidebook.tex
--- nethack-3.4.0./doc/Guidebook.tex	Wed Jun 12 00:29:06 2002
+++ nethack-3.4.0/doc/Guidebook.tex	Wed Jun 12 00:29:19 2002
@@ -2112,6 +2112,13 @@
 Name your starting dog (ex.\ ``{\tt dogname:Fang}'').
 Cannot be set with the `{\tt O}' command.
 %.lp
+\item[\ib{dumpfile}]
+The name of a file where the disclosure information is written when the 
+game ends. You may use the macro %n that will be replaced with the name 
+of your player character. The game must have write permissions to the 
+directory where the file is written. Normally /tmp may be used for unix 
+systems.
+%.lp
 \item[\ib{dungeon}]
 Set the graphics symbols for displaying the dungeon (default
 ``\verb& |--------||.-|++##& \verb&.##<><>_|\\#{}.}..## #}&'').
diff -ruN nethack-3.4.0./doc/Guidebook.txt nethack-3.4.0/doc/Guidebook.txt
--- nethack-3.4.0./doc/Guidebook.txt	Wed Jun 12 00:29:06 2002
+++ nethack-3.4.0/doc/Guidebook.txt	Wed Jun 12 00:29:19 2002
@@ -2194,6 +2194,13 @@
                Name your starting dog (ex.  ``dogname:Fang'').   Cannot  be
                set with the `O' command.
 
+          dumpfile
+               The name of a file where the disclosure information is
+	       written when the game ends. You may use the macro %n that
+	       will be replaced with the name of your player character.
+	       The game must have write permissions to the directory where
+	       the file is written. Normally /tmp may be used for unix systems.
+
           dungeon
                Set the graphics symbols for displaying the dungeon (default
                `` |--------||.-|++##.##<><>_|\\#{}.}..## #}'').   The  dun-
diff -ruN nethack-3.4.0./include/config.h nethack-3.4.0/include/config.h
--- nethack-3.4.0./include/config.h	Wed Jun 12 00:29:06 2002
+++ nethack-3.4.0/include/config.h	Wed Jun 12 00:29:19 2002
@@ -348,6 +348,8 @@
  * bugs left here.
  */
 
+#define DUMP_LOG	/* dump log patch */                                    
+#define DUMP_FN		"/var/games/nethack/%n.dump"
 #define SHOW_BORN	/* show born patch */
 /*#define GOLDOBJ */	/* Gold is kept on obj chains - Helge Hafting */
 
diff -ruN nethack-3.4.0./include/decl.h nethack-3.4.0/include/decl.h
--- nethack-3.4.0./include/decl.h	Thu Apr 11 17:58:27 2002
+++ nethack-3.4.0/include/decl.h	Wed Jun 12 00:29:19 2002
@@ -183,6 +183,9 @@
 E const char *configfile;
 E NEARDATA char plname[PL_NSIZ];
 E NEARDATA char dogname[];
+#ifdef DUMP_LOG
+E NEARDATA char dump_fn[];	/* dump patch */
+#endif
 E NEARDATA char catname[];
 E NEARDATA char horsename[];
 E char preferred_pet;
diff -ruN nethack-3.4.0./include/extern.h nethack-3.4.0/include/extern.h
--- nethack-3.4.0./include/extern.h	Thu Apr 11 17:58:27 2002
+++ nethack-3.4.0/include/extern.h	Wed Jun 12 00:29:19 2002
@@ -165,6 +165,10 @@
 E int NDECL(extcmd_via_menu);
 E void FDECL(enlightenment, (int));
 E void FDECL(show_conduct, (int));
+#ifdef DUMP_LOG
+E void FDECL(dump_enligthenment, (int));
+E void FDECL(dump_conduct, (int));
+#endif
 E int FDECL(xytod, (SCHAR_P,SCHAR_P));
 E void FDECL(dtoxy, (coord *,int));
 E int FDECL(movecmd, (CHAR_P));
@@ -278,6 +282,7 @@
 E void FDECL(row_refresh, (int,int,int));
 E void NDECL(cls);
 E void FDECL(flush_screen, (int));
+E void NDECL(dump_screen);
 E int FDECL(back_to_glyph, (XCHAR_P,XCHAR_P));
 E int FDECL(zapdir_to_glyph, (int,int,int));
 E int FDECL(glyph_at, (XCHAR_P,XCHAR_P));
@@ -543,6 +548,9 @@
 #if !defined(MAKEDEFS_C) && !defined(LEV_LEX_C)
 E void FDECL(done, (int));
 E void FDECL(container_contents, (struct obj *,BOOLEAN_P,BOOLEAN_P));
+#ifdef DUMP_LOG
+E void FDECL(do_container_contents, (struct obj *,BOOLEAN_P,BOOLEAN_P,BOOLEAN_P));
+#endif
 E void FDECL(terminate, (int));
 E int NDECL(num_genocides);
 
@@ -765,6 +773,9 @@
 E char *FDECL(xprname, (struct obj *,const char *,CHAR_P,BOOLEAN_P,long,long));
 E int NDECL(ddoinv);
 E char FDECL(display_inventory, (const char *,BOOLEAN_P));
+#ifdef DUMP_LOG
+E char FDECL(dump_inventory, (const char *,BOOLEAN_P));
+#endif
 E int FDECL(display_binventory, (int,int,BOOLEAN_P));
 E struct obj *FDECL(display_cinventory,(struct obj *));
 E struct obj *FDECL(display_minventory,(struct monst *,int,char *));
@@ -2168,6 +2179,9 @@
 E int NDECL(abon);
 E int NDECL(dbon);
 E int NDECL(enhance_weapon_skill);
+#ifdef DUMP_LOG
+E void NDECL(dump_weapon_skill);
+#endif
 E void FDECL(unrestrict_weapon_skill, (int));
 E void FDECL(use_skill, (int,int));
 E void FDECL(add_weapon_skill, (int));
diff -ruN nethack-3.4.0./src/botl.c nethack-3.4.0/src/botl.c
--- nethack-3.4.0./src/botl.c	Thu Apr 11 17:58:27 2002
+++ nethack-3.4.0/src/botl.c	Wed Jun 12 00:29:19 2002
@@ -163,10 +163,16 @@
 }
 #endif
 
+#ifdef DUMP_LOG
+void bot1str(char *newbot1)
+#else
 STATIC_OVL void
 bot1()
+#endif
 {
+#ifndef DUMP_LOG
 	char newbot1[MAXCO];
+#endif
 	register char *nb;
 	register int i,j;
 
@@ -213,6 +219,15 @@
 	if (flags.showscore)
 	    Sprintf(nb = eos(nb), " S:%ld", botl_score());
 #endif
+#ifdef DUMP_LOG
+}
+STATIC_OVL void
+bot1()
+{
+	char newbot1[MAXCO];
+
+	bot1str(newbot1);
+#endif
 	curs(WIN_STATUS, 1, 0);
 	putstr(WIN_STATUS, 0, newbot1);
 }
@@ -240,10 +255,17 @@
 	return ret;
 }
 
+#ifdef DUMP_LOG
+void bot2str(newbot2)
+char* newbot2;
+#else
 STATIC_OVL void
 bot2()
+#endif
 {
+#ifndef DUMP_LOG
 	char  newbot2[MAXCO];
+#endif
 	register char *nb;
 	int hp, hpmax;
 	int cap = near_capacity();
@@ -290,6 +312,14 @@
 	if(Slimed)         Sprintf(nb = eos(nb), " Slime");
 	if(cap > UNENCUMBERED)
 		Sprintf(nb = eos(nb), " %s", enc_stat[cap]);
+#ifdef DUMP_LOG
+}
+STATIC_OVL void
+bot2()
+{
+	char newbot2[MAXCO];
+	bot2str(newbot2);
+#endif
 	curs(WIN_STATUS, 1, 1);
 	putstr(WIN_STATUS, 0, newbot2);
 }
diff -ruN nethack-3.4.0./src/cmd.c nethack-3.4.0/src/cmd.c
--- nethack-3.4.0./src/cmd.c	Wed Jun 12 00:29:06 2002
+++ nethack-3.4.0/src/cmd.c	Wed Jun 12 00:29:19 2002
@@ -1044,6 +1044,287 @@
 	return;
 }
 
+#ifdef DUMP_LOG
+void
+dump_enlightenment(final)
+int final;
+{
+	int ltmp;
+	char buf[BUFSZ];
+	char buf2[BUFSZ];
+	const char *enc_stat[] = { /* copied from botl.c */
+	  "",
+	  "burdened",
+	  "stressed",
+	  "strained",
+	  "overtaxed",
+	  "overloaded"
+	};
+	dump("", "Final attributes");
+#ifdef ELBERETH
+	if (u.uevent.uhand_of_elbereth) {
+	    static const char *hofe_titles[3] = {
+				"the Hand of Elbereth",
+				"the Envoy of Balance",
+				"the Glory of Arioch"
+	    };
+	    dump("  You were ",
+		   (char *)hofe_titles[u.uevent.uhand_of_elbereth - 1]);
+	}
+#endif
+	if (u.ualign.record >= 20)	dump("  You were ", "piously aligned");
+	else if (u.ualign.record > 13)	dump("  You were ", "devoutly aligned");
+	else if (u.ualign.record > 8)
+	  dump("  You were ", "fervently aligned");
+	else if (u.ualign.record > 3)
+	  dump("  You were ", "stridently aligned");
+	else if (u.ualign.record == 3)
+	  dump("  You were ", "aligned");
+	else if (u.ualign.record > 0)
+	  dump("  You were ", "haltingly aligned");
+	else if (u.ualign.record == 0)
+	  dump("  You were ", "nominally aligned");
+	else if (u.ualign.record >= -3)	dump("  You have ", "strayed");
+	else if (u.ualign.record >= -8)	dump("  You have ", "sinned");
+	else dump("  You have ", "transgressed");
+
+#ifdef WIZARD
+	if (wizard) {
+		Sprintf(buf, " %d", u.ualign.record);
+		dump("  Your alignment was ", buf);
+	}
+#endif
+
+	/*** Resistances to troubles ***/
+	if (Fire_resistance) dump("  You were ", "fire resistant");
+	if (Cold_resistance) dump("  You were ", "cold resistant");
+	if (Sleep_resistance) dump("  You were ", "sleep resistant");
+	if (Disint_resistance) dump("  You were ", "disintegration-resistant");
+	if (Shock_resistance) dump("  You were ", "shock resistant");
+	if (Poison_resistance) dump("  You were ", "poison resistant");
+	if (Drain_resistance) dump("  You were ", "level-drain resistant");
+	if (Sick_resistance) dump("  You were ", "immune to sickness");
+	if (Antimagic) dump("  You were ", "magic-protected");
+	if (Acid_resistance) dump("  You were ", "acid resistant");
+	if (Stone_resistance) dump("  You were ", "petrification resistant");
+	if (Invulnerable) dump("  You were ", "invulnerable");
+	if (u.uedibility) dump("  You could ", "recognize detrimental food");
+
+	/*** Troubles ***/
+	if (Halluc_resistance) 	dump("  ", "You resisted hallucinations");
+	if (Hallucination) dump("  You were ", "hallucinating");
+	if (Stunned) dump("  You were ", "stunned");
+	if (Confusion) dump("  You were ", "confused");
+	if (Blinded) dump("  You were ", "blinded");
+	if (Sick) {
+		if (u.usick_type & SICK_VOMITABLE)
+			dump("  You were ", "sick from food poisoning");
+			if (u.usick_type & SICK_NONVOMITABLE)
+				dump("  You were ", "sick from illness");
+	}
+	/* added by JDS */
+	if (u.uhitinc) {
+	  Sprintf(buf, "%s%i %s to hit", u.uhitinc > 0 ? "+" : "",
+		  u.uhitinc, u.uhitinc > 0 ? "bonus" : "penalty");
+	  dump("  You had ", buf);
+	}
+	if (u.udaminc) {
+		Sprintf(buf, "%s%i %s to damage", u.udaminc > 0 ? "+" : "",
+				u.udaminc, u.udaminc > 0 ? "bonus" : "penalty");
+		dump("  You had ", buf);
+	} /* end JDS portion */
+	if (Stoned) dump("  You were ", "turning to stone");
+	if (Slimed) dump("  You were ", "turning into slime");
+	if (Strangled)
+	  dump("  You were ", (u.uburied) ? "buried" : "being strangled");
+	if (Glib) {
+		Sprintf(buf, "slippery %s", makeplural(body_part(FINGER)));
+		dump("  You had ", buf);
+	}
+	if (Fumbling) dump("  ", "You fumbled");
+	if (Wounded_legs
+#ifdef STEED
+	    && !u.usteed
+#endif
+			  ) {
+		Sprintf(buf, "wounded %s", makeplural(body_part(LEG)));
+		dump("  You had ", buf);
+	}
+#if defined(WIZARD) && defined(STEED)
+	if (Wounded_legs && u.usteed && wizard) {
+	    Strcpy(buf, x_monnam(u.usteed, ARTICLE_YOUR, (char *)0, 
+		    SUPPRESS_SADDLE | SUPPRESS_HALLUCINATION, FALSE));
+	    *buf = highc(*buf);
+	    Strcat(buf, " had wounded legs");
+	    dump("  ", buf);
+	}
+#endif
+	if (Sleeping) dump("  ", "You fell asleep");
+	if (Hunger) dump("  ", "You hungered rapidly");
+
+	/*** Vision and senses ***/
+	if (See_invisible) dump("  ", "You saw invisible");
+	if (Blind_telepat) dump("  ", "You were telepathic");
+	if (Warning) dump("  ", "You were warned");
+	if (Warn_of_mon && flags.warntype) {
+		Sprintf(buf, "aware of the presence of %s",
+			(flags.warntype & M2_ORC) ? "orcs" :
+			(flags.warntype & M2_DEMON) ? "demons" :
+			something); 
+		dump("  You were ", buf);
+	}
+	if (Undead_warning) dump("  You were ", "warned of undead");
+	if (Searching) dump("  You had ", "automatic searching");
+	if (Clairvoyant) dump("  You were ", "clairvoyant");
+	if (Infravision) dump("  You had ", "infravision");
+	if (Detect_monsters)
+	  dump("  You were ", "sensing the presence of monsters");
+	if (u.umconf) dump("  You were ", "going to confuse monsters");
+
+	/*** Appearance and behavior ***/
+	if (Adornment) dump("  You were ", "adorned");
+	if (Invisible) dump("  You were ", "invisible");
+	else if (Invis) dump("  You were ", "invisible to others");
+	/* ordinarily "visible" is redundant; this is a special case for
+	   the situation when invisibility would be an expected attribute */
+	else if ((HInvis || EInvis || pm_invisible(youmonst.data)) && BInvis)
+	    dump("  You were ", "visible");
+	if (Displaced) dump("  You were ", "displaced");
+	if (Stealth) dump("  You were ", "stealthy");
+	if (Aggravate_monster) dump("  ", "You aggravated monsters");
+	if (Conflict) dump("  ", "You caused conflict");
+
+	/*** Transportation ***/
+	if (Jumping) dump("  You could ", "jump");
+	if (Teleportation) dump("  You could ", "teleport");
+	if (Teleport_control) dump("  You had ", "teleport control");
+	if (Lev_at_will) dump("  You were ", "levitating, at will");
+	else if (Levitation)
+	  dump("  You were ", "levitating");	/* without control */
+	else if (Flying) dump("  You could ", "fly");
+	if (Wwalking) dump("  You could ", "walk on water");
+	if (Swimming) dump("  You could ", "swim");        
+	if (Breathless) dump("  You could ", "survive without air");
+	else if (Amphibious) dump("  You could ", "breathe water");
+	if (Passes_walls) dump("  You could ", "walk through walls");
+#ifdef STEED
+	if (u.usteed) {
+	    Sprintf(buf, "riding %s", y_monnam(u.usteed));
+	    dump("  You were ", buf);
+	}
+#endif
+	if (u.uswallow) {
+	    Sprintf(buf, "swallowed by %s", a_monnam(u.ustuck));
+#ifdef WIZARD
+	    if (wizard) Sprintf(eos(buf), " (%u)", u.uswldtim);
+#endif
+	    dump("  You were ", buf);
+	} else if (u.ustuck) {
+	    Sprintf(buf, "%s %s",
+		    (Upolyd && sticks(youmonst.data)) ? "holding" : "held by",
+		    a_monnam(u.ustuck));
+	    dump("  You were ", buf);
+	}
+
+	/*** Physical attributes ***/
+	if (Slow_digestion) dump("  You had ", "slower digestion");
+	if (Regeneration) dump("  ", "You regenerated");
+	if (u.uspellprot || Protection) dump("  You were ", "protected");
+	if (Protection_from_shape_changers)
+		dump("  You were ", "protected from shape changers");
+	if (Polymorph) dump("  You were ", "polymorphing");
+	if (Polymorph_control) dump("  You had ", "polymorph control");
+	if (u.ulycn >= LOW_PM) {
+		Strcpy(buf, an(mons[u.ulycn].mname));
+		dump("  You were ", buf);
+	}
+	if (Upolyd) {
+	    if (u.ulycn >= LOW_PM) Strcpy(buf, "in beast form");
+	    else Sprintf(buf, "polymorphed into %s", an(youmonst.data->mname));
+#ifdef WIZARD
+	    if (wizard) Sprintf(eos(buf), " (%d)", u.mtimedone);
+#endif
+	    dump("  You were ", buf);
+	}
+	if (Unchanging)
+	  dump("  You could ", "not change from your current form");
+	if (Fast) dump("  You were ", Very_fast ? "very fast" : "fast");
+	if (Reflecting) dump("  You had ", "reflection");
+	if (Free_action) dump("  You had ", "free action");
+	if (Fixed_abil) dump("  You had ", "fixed abilities");
+	if (Lifesaved)
+		dump("  ", "Your life would have been saved");
+	if (u.twoweap) dump("  You were ", "wielding two weapons at once");
+
+	/*** Miscellany ***/
+	if (Luck) {
+	    ltmp = abs((int)Luck);
+	    Sprintf(buf, "%s%slucky",
+		    ltmp >= 10 ? "extremely " : ltmp >= 5 ? "very " : "",
+		    Luck < 0 ? "un" : "");
+#ifdef WIZARD
+	    if (wizard) Sprintf(eos(buf), " (%d)", Luck);
+#endif
+	    dump("  You were ", buf);
+	}
+#ifdef WIZARD
+	 else if (wizard) dump("  ", "Your luck was zero");
+#endif
+	if (u.moreluck > 0) dump("  You had ", "extra luck");
+	else if (u.moreluck < 0) dump("  You had ", "reduced luck");
+	if (carrying(LUCKSTONE) || stone_luck(TRUE)) {
+	    ltmp = stone_luck(FALSE);
+	    if (ltmp <= 0)
+		dump("  ", "Bad luck did not time out for you");
+	    if (ltmp >= 0)
+		dump("  ", "Good luck did not time out for you");
+	}
+
+	if (u.ugangr) {
+	    Sprintf(buf, " %sangry with you",
+		    u.ugangr > 6 ? "extremely " : u.ugangr > 3 ? "very " : "");
+#ifdef WIZARD
+	    if (wizard) Sprintf(eos(buf), " (%d)", u.ugangr);
+#endif
+	    Sprintf(buf2, "%s was %s", u_gname(), buf);
+	    dump("  ", buf2);
+	}
+
+    {
+	const char *p;
+
+	buf[0] = '\0';
+	if (final < 2) {    /* quit/escaped/ascended */
+	    p = "survived after being killed ";
+	    switch (u.umortality) {
+	    case 0:  p = !final ? (char *)0 : "survived";  break;
+	    case 1:  Strcpy(buf, "once");  break;
+	    case 2:  Strcpy(buf, "twice");  break;
+	    case 3:  Strcpy(buf, "thrice");  break;
+	    default: Sprintf(buf, "%d times", u.umortality);
+		     break;
+	    }
+	} else {		/* game ended in character's death */
+	    p = "are dead";
+	    switch (u.umortality) {
+	    case 0:  impossible("dead without dying?");
+	    case 1:  break;			/* just "are dead" */
+	    default: Sprintf(buf, " (%d%s time!)", u.umortality,
+			     ordin(u.umortality));
+		     break;
+	    }
+	}
+	if (p) {
+	  Sprintf(buf2, "You %s %s", p, buf);
+	  dump("  ", buf2);
+	}
+    }
+	dump("", "");
+	return;
+
+} /* dump_enlightenment */
+#endif 
+
 /*
  * Courtesy function for non-debug, non-explorer mode players
  * to help refresh them about who/what they are.
@@ -1246,6 +1527,90 @@
 	destroy_nhwindow(en_win);
 }
 
+#ifdef DUMP_LOG
+void
+dump_conduct(final)
+int final;
+{
+	char buf[BUFSZ];
+	int ngenocided;
+
+	dump("", "Voluntary challenges");
+
+	if (!u.uconduct.food)
+	    dump("", "  You went without food");
+	    /* But beverages are okay */
+	else if (!u.uconduct.unvegan)
+	    dump("", "  You followed a strict vegan diet");
+	else if (!u.uconduct.unvegetarian)
+	    dump("", "  You were a vegetarian");
+
+	if (!u.uconduct.gnostic)
+	    dump("", "  You were an atheist");
+
+	if (!u.uconduct.weaphit)
+	    dump("", "  You never hit with a wielded weapon");
+#ifdef WIZARD
+	else if (wizard) {
+	    Sprintf(buf, "used a wielded weapon %ld time%s",
+		    u.uconduct.weaphit, plur(u.uconduct.weaphit));
+	    dump("  You have ", buf);
+	}
+#endif
+	if (!u.uconduct.killer)
+	    dump("", "  You were a pacifist");
+
+	if (!u.uconduct.literate)
+	    dump("", "  You were illiterate");
+#ifdef WIZARD
+	else if (wizard) {
+	    Sprintf(buf, "read items or engraved %ld time%s",
+		    u.uconduct.literate, plur(u.uconduct.literate));
+	    dump("  You ", buf);
+	}
+#endif
+
+	ngenocided = num_genocides();
+	if (ngenocided == 0) {
+	    dump("", "  You never genocided any monsters");
+	} else {
+	    Sprintf(buf, "genocided %d type%s of monster%s",
+		    ngenocided, plur(ngenocided), plur(ngenocided));
+	    dump("  You ", buf);
+	}
+
+	if (!u.uconduct.polypiles)
+	    dump("", "  You never polymorphed an object");
+	else {
+	    Sprintf(buf, "polymorphed %ld item%s",
+		    u.uconduct.polypiles, plur(u.uconduct.polypiles));
+	    dump("  You ", buf);
+	}
+
+	if (!u.uconduct.polyselfs)
+	    dump("", "  You never changed form");
+	else {
+	    Sprintf(buf, "changed form %ld time%s",
+		    u.uconduct.polyselfs, plur(u.uconduct.polyselfs));
+	    dump("  You ", buf);
+	}
+
+	if (!u.uconduct.wishes)
+	    dump("", "  You used no wishes");
+	else {
+	    Sprintf(buf, "used %ld wish%s",
+		    u.uconduct.wishes, (u.uconduct.wishes > 1L) ? "es" : "");
+	    dump("  You ", buf);
+
+	    if (!u.uconduct.wisharti)
+		dump("", "  You did not wish for any artifacts");
+	}
+
+	dump("", "");
+}
+
+#endif /* DUMP_LOG */
+
 #endif /* OVLB */
 #ifdef OVL1
 
diff -ruN nethack-3.4.0./src/decl.c nethack-3.4.0/src/decl.c
--- nethack-3.4.0./src/decl.c	Thu Apr 11 17:58:27 2002
+++ nethack-3.4.0/src/decl.c	Wed Jun 12 00:29:19 2002
@@ -195,6 +195,15 @@
 /* used to zero all elements of a struct obj */
 NEARDATA struct obj zeroobj = DUMMY;
 
+/* originally from end.c */
+#ifdef DUMP_LOG
+#ifdef DUMP_FN
+NEARDATA char dump_fn[] = DUMP_FN;
+#else
+NEARDATA char dump_fn[PL_PSIZ] = DUMMY;
+#endif
+#endif
+
 /* originally from dog.c */
 NEARDATA char dogname[PL_PSIZ] = DUMMY;
 NEARDATA char catname[PL_PSIZ] = DUMMY;
diff -ruN nethack-3.4.0./src/display.c nethack-3.4.0/src/display.c
--- nethack-3.4.0./src/display.c	Thu Apr 11 17:58:27 2002
+++ nethack-3.4.0/src/display.c	Wed Jun 12 00:29:19 2002
@@ -1339,6 +1339,82 @@
 
 /* ========================================================================= */
 
+#ifdef DUMP_LOG
+/* D: Added to dump screen to output file */
+STATIC_PTR uchar get_glyph_char(glyph)
+int glyph;
+{
+    uchar   ch;
+    register int offset;
+
+    if (glyph >= NO_GLYPH)
+        return ;
+
+    /*
+     *  Map the glyph back to a character.
+     *
+     *  Warning:  For speed, this makes an assumption on the order of
+     *		  offsets.  The order is set in display.h.
+     */
+    if ((offset = (glyph - GLYPH_WARNING_OFF)) >= 0) {	/* a warning flash */
+	ch = def_warnsyms[offset].sym;
+    } else if ((offset = (glyph - GLYPH_SWALLOW_OFF)) >= 0) {	/* swallow */
+	/* see swallow_to_glyph() in display.c */
+	ch = (uchar) defsyms[S_sw_tl + (offset & 0x7)].sym;
+    } else if ((offset = (glyph - GLYPH_ZAP_OFF)) >= 0) {	/* zap beam */
+	/* see zapdir_to_glyph() in display.c */
+	ch = defsyms[S_vbeam + (offset & 0x3)].sym;
+    } else if ((offset = (glyph - GLYPH_CMAP_OFF)) >= 0) {	/* cmap */
+	ch = defsyms[offset].sym;
+    } else if ((offset = (glyph - GLYPH_OBJ_OFF)) >= 0) {	/* object */
+	ch = def_oc_syms[(int)objects[offset].oc_class];
+    } else if ((offset = (glyph - GLYPH_RIDDEN_OFF)) >= 0) {	/* mon ridden */
+	ch = def_monsyms[(int)mons[offset].mlet];
+    } else if ((offset = (glyph - GLYPH_BODY_OFF)) >= 0) {	/* a corpse */
+	ch = def_oc_syms[(int)objects[CORPSE].oc_class];
+    } else if ((offset = (glyph - GLYPH_DETECT_OFF)) >= 0) {	/* mon detect */
+	ch = def_monsyms[(int)mons[offset].mlet];
+    } else if ((offset = (glyph - GLYPH_INVIS_OFF)) >= 0) {	/* invisible */
+	ch = DEF_INVISIBLE;
+    } else if ((offset = (glyph - GLYPH_PET_OFF)) >= 0) {	/* a pet */
+	ch = def_monsyms[(int)mons[offset].mlet];
+    } else {							/* a monster */
+	ch = monsyms[(int)mons[glyph].mlet];
+    }
+    return ch;
+}
+
+/* Take a screen dump */
+void dump_screen()
+{
+    register int x,y;
+    int lastc;
+    /* D: botl.c has a closer approximation to the size, but we'll go with
+     *    this */
+    char buf[300], *ptr;
+    
+    for (y = 0; y < ROWNO; y++) {
+	lastc = 0;
+	ptr = buf;
+	for (x = 1; x < COLNO; x++) {
+	    uchar c = get_glyph_char(gbuf[y][x].glyph);
+	    *ptr++ = c;
+	    if (c != ' ')
+		lastc = x;
+	}
+	buf[lastc] = '\0';
+	dump("", buf);
+    }
+    dump("", "");
+    bot1str(buf);
+    dump("", buf);
+    bot2str(buf);
+    dump("", buf);
+    dump("", "");
+    dump("", "");
+}
+#endif /* DUMP_LOG */
+
 /*
  * back_to_glyph()
  *
diff -ruN nethack-3.4.0./src/end.c nethack-3.4.0/src/end.c
--- nethack-3.4.0./src/end.c	Wed Jun 12 00:29:06 2002
+++ nethack-3.4.0/src/end.c	Wed Jun 12 00:31:14 2002
@@ -41,7 +41,12 @@
 STATIC_DCL void FDECL(display_artifact_score, (struct obj *,winid));
 STATIC_DCL void FDECL(savelife, (int));
 void FDECL(list_vanquished, (int, BOOLEAN_P));	/* showborn patch */
+#ifdef DUMP_LOG
+void FDECL(do_vanquished, (int, BOOLEAN_P, BOOLEAN_P));
+STATIC_DCL void FDECL(list_genocided, (int, BOOLEAN_P, BOOLEAN_P));
+#else
 STATIC_DCL void FDECL(list_genocided, (int, BOOLEAN_P));
+#endif
 STATIC_DCL boolean FDECL(should_query_disclose_option, (int, int*));
 
 #if defined(__BEOS__) || defined(MICRO) || defined(WIN32) || defined(OS2)
@@ -83,6 +88,52 @@
 
 extern const char *killed_by_prefix[];
 
+#ifdef DUMP_LOG
+FILE *dump_fp = (FILE *)0;  /* file pointer for dumps */
+/* functions dump_init, dump_exit and dump are from the dump patch */
+
+void
+dump_init ()
+{
+  if (dump_fn) {
+    char *p = strstr(dump_fn, "%n");
+    if (p) {
+      char buf[BUFSZ];
+      if (p == dump_fn)
+	buf[0] = 0;
+      else
+      {
+        strncpy(buf, dump_fn, (int)p - (int)dump_fn);
+        buf[(int)p-(int)dump_fn]='\0';
+      }
+      strncat(buf, plname, BUFSZ - strlen(buf));
+      p += 2;
+      if (strlen(buf) < BUFSZ && strlen(p) > 0)
+	strncat(buf, p, BUFSZ - strlen(buf));
+      strcpy(dump_fn, buf);
+    }
+    dump_fp = fopen (dump_fn, "w");
+    if (!dump_fp) {
+      pline("Can't open %s for output.", dump_fn);
+      pline("Dump file not created.");
+    }
+  }
+}
+
+void
+dump_exit ()
+{
+  if (dump_fp)
+    fclose (dump_fp);
+}
+
+void dump (pre, str)
+     char *pre, *str;
+{
+  if (dump_fp)
+    fprintf (dump_fp, "%s%s\n", pre, str);
+}
+#endif  /* DUMP_LOG */
 
 /*ARGSUSED*/
 void
@@ -351,8 +402,13 @@
 			    makeknown(obj->otyp);
 			    obj->known = obj->bknown = obj->dknown = obj->rknown = 1;
 			}
+#ifdef DUMP_LOG
+			(void) dump_inventory((char *)0, TRUE);
+			do_container_contents(invent, TRUE, TRUE, TRUE);
+#else
 			(void) display_inventory((char *)0, TRUE);
 			container_contents(invent, TRUE, TRUE);
+#endif
 		}
 		if (ask && c == 'q')  done_stopprint++;
 	    }
@@ -366,14 +422,25 @@
 		enlightenment(how >= PANICKED ? 1 : 2); /* final */
 	    if (ask && c == 'q') done_stopprint++;
 	}
+#ifdef DUMP_LOG
+	if (dump_fn) dump_enlightenment(how >= PANICKED ? 1 : 2);
+#endif
 
 	ask = should_query_disclose_option('v', &defquery);
 	if (!done_stopprint)
+#ifdef DUMP_LOG
+	    do_vanquished(defquery, ask, TRUE);
+#else
 	    list_vanquished(defquery, ask);
+#endif
 
 	ask = should_query_disclose_option('g', &defquery);
 	if (!done_stopprint)
+#ifdef DUMP_LOG
+	    list_genocided(defquery, ask,TRUE);
+#else
 	    list_genocided(defquery, ask);
+#endif
 
 	ask = should_query_disclose_option('c', &defquery);
 	if (!done_stopprint) {
@@ -383,6 +450,12 @@
 		show_conduct(how >= PANICKED ? 1 : 2);
 	    if (ask && c == 'q') done_stopprint++;
 	}
+#ifdef DUMP_LOG
+	if (dump_fn) {
+	  dump_conduct(how >= PANICKED ? 1 : 2);
+	  dump_weapon_skill();
+	}
+#endif
 }
 
 /* try to get the player back in a viable state after being killed */
@@ -514,6 +587,10 @@
 		arti_cost(otmp), currency(2L), 
 		arti_cost(otmp) * 5 / 2);
 	    putstr(endwin, 0, pbuf);
+#ifdef DUMP_LOG
+	    if (dump_fn)
+	      dump("",pbuf);
+#endif
 	}
 	if (Has_contents(otmp))
 	    display_artifact_score(otmp->cobj,endwin);
@@ -593,6 +670,22 @@
 
 die:
 	program_state.gameover = 1;
+#ifdef DUMP_LOG
+	/* D: Grab screen dump right here */
+	if (dump_fn) {
+	  dump_init();
+	  Sprintf(pbuf, "%s, %s %s %s %s", plname,
+		  aligns[1 - u.ualign.type].adj,
+		  genders[flags.female].adj,
+		  urace.adj,
+		  (flags.female && urole.name.f)?
+		      urole.name.f : urole.name.m);
+	  dump("", pbuf);
+	  /* D: Add a line for clearance from the screen dump */
+	  dump("", "");
+	  dump_screen();
+	}
+#endif
 	/* in case of a subsequent panic(), there's no point trying to save */
 	program_state.something_worth_saving = 0;
 	/* render vision subsystem inoperative */
@@ -740,15 +833,19 @@
 		/* don't bother counting to see whether it should be plural */
 	}
 
+	Sprintf(pbuf, "%s %s the %s...", Goodbye(), plname,
+		how != ASCENDED ?
+		   (const char *) ((flags.female && urole.name.f) ?
+				   urole.name.f : urole.name.m) :
+		   (const char *) (flags.female ? "Demigoddess" : "Demigod"));
 	if (!done_stopprint) {
-	    Sprintf(pbuf, "%s %s the %s...", Goodbye(), plname,
-		   how != ASCENDED ?
-		      (const char *) ((flags.female && urole.name.f) ?
-		         urole.name.f : urole.name.m) :
-		      (const char *) (flags.female ? "Demigoddess" : "Demigod"));
 	    putstr(endwin, 0, pbuf);
 	    putstr(endwin, 0, "");
 	}
+#ifdef DUMP_LOG
+	if (dump_fn)
+	  dump("",pbuf);
+#endif
 
 	if (how == ESCAPED || how == ASCENDED) {
 	    register struct monst *mtmp;
@@ -788,13 +885,17 @@
 	    } else {
 		if (!done_stopprint) Strcat(pbuf, " ");
 	    }
-	    if (!done_stopprint) {
-		Sprintf(eos(pbuf), "%s with %ld point%s,",
+	    Sprintf(eos(pbuf), "%s with %ld point%s,",
 			how==ASCENDED ? "went to your reward" :
 					"escaped from the dungeon",
 			u.urexp, plur(u.urexp));
+	    if (!done_stopprint) {
 		putstr(endwin, 0, pbuf);
 	    }
+#ifdef DUMP_LOG
+	    if (dump_fn)
+	      dump("",pbuf);
+#endif
 
 	    if (!done_stopprint)
 		display_artifact_score(invent,endwin);
@@ -824,6 +925,10 @@
 				count, plur(count));
 		    }
 		    putstr(endwin, 0, pbuf);
+#ifdef DUMP_LOG
+		    if (dump_fn)
+		      dump("",pbuf);
+#endif
 		}
 	    }
 
@@ -848,12 +953,23 @@
 	    Sprintf(eos(pbuf), " with %ld point%s,",
 		    u.urexp, plur(u.urexp));
 	    putstr(endwin, 0, pbuf);
+#ifdef DUMP_LOG
+	    if (dump_fn)
+	      dump("",pbuf);
+#endif
 	}
 
 	if (!done_stopprint) {
 	    Sprintf(pbuf, "and %ld piece%s of gold, after %ld move%s.",
 		    umoney, plur(umoney), moves, plur(moves));
 	    putstr(endwin, 0, pbuf);
+#ifdef DUMP_LOG
+	    if (dump_fn) {
+	      dump("",pbuf);
+	      Sprintf(pbuf, "Killer: %s",killer);
+	      dump("",pbuf);
+	    }
+#endif
 	}
 	if (!done_stopprint) {
 	    Sprintf(pbuf,
@@ -861,6 +977,10 @@
 		    u.ulevel, u.uhpmax, plur(u.uhpmax), ends[how]);
 	    putstr(endwin, 0, pbuf);
 	    putstr(endwin, 0, "");
+#ifdef DUMP_LOG
+	    if (dump_fn)
+	      dump("",pbuf);
+#endif
 	}
 	if (!done_stopprint)
 	    display_nhwindow(endwin, TRUE);
@@ -878,6 +998,10 @@
 		exit_nhwindows((char *)0);
 	    topten(how);
 	}
+#ifdef DUMP_LOG
+	if (dump_fn)
+	  dump_exit();
+#endif
 
 	if(done_stopprint) { raw_print(""); raw_print(""); }
 	terminate(EXIT_SUCCESS);
@@ -888,9 +1012,20 @@
 container_contents(list, identified, all_containers)
 struct obj *list;
 boolean identified, all_containers;
+#ifdef DUMP_LOG
+{
+  do_container_contents(list, identified, all_containers, FALSE);
+}
+
+void do_container_contents(list, identified, all_containers, want_dump)
+struct obj *list;
+boolean identified, all_containers, want_dump;
+#endif
+/* The original container_contents function */
 {
 	register struct obj *box, *obj;
-	char buf[BUFSZ];
+	char buf[BUFSZ], *invlet;
+	int classcount;
 
 	for (box = list; box; box = box->nobj) {
 	    if (Is_container(box) && box->otyp != BAG_OF_TRICKS) {
@@ -899,26 +1034,68 @@
 		    Sprintf(buf, "Contents of %s:", the(xname(box)));
 		    putstr(tmpwin, 0, buf);
 		    putstr(tmpwin, 0, "");
+#ifdef DUMP_LOG
+		    if (want_dump)
+		      dump("", buf);
+#endif
+		    invlet = flags.inv_order;
+nextclass:
+		    classcount = 0;
 		    for (obj = box->cobj; obj; obj = obj->nobj) {
+		      if (!flags.sortpack || obj->oclass == *invlet
+#ifdef DUMP_LOG
+			  || !want_dump
+#endif
+			  ) {
 			if (identified) {
 			    makeknown(obj->otyp);
 			    obj->known = obj->bknown =
 			    obj->dknown = obj->rknown = 1;
 			}
 			putstr(tmpwin, 0, doname(obj));
+#ifdef DUMP_LOG
+			if (want_dump)
+			    dump("", doname(obj));
+#endif
+		      }
 		    }
+		    if (flags.sortpack
+#ifdef DUMP_LOG
+			&& want_dump
+#endif
+			) {
+		      if (*++invlet)
+			goto nextclass;
+		    }
+
 		    display_nhwindow(tmpwin, TRUE);
 		    destroy_nhwindow(tmpwin);
-		    if (all_containers)
+		    if (all_containers) {
+#ifdef DUMP_LOG
+			if (want_dump)
+			  dump("", "");
+			do_container_contents(box->cobj, identified, TRUE,
+					   want_dump);
+#else
 			container_contents(box->cobj, identified, TRUE);
+#endif
+		    }
 		} else {
 		    pline("%s empty.", Tobjnam(box, "are"));
 		    display_nhwindow(WIN_MESSAGE, FALSE);
+#ifdef DUMP_LOG
+		    if (want_dump)
+		      dump(The(xname(box)), " is empty.");
+#endif
 		}
 	    }
 	    if (!all_containers)
 		break;
 	}
+#ifdef DUMP_LOG
+	if (want_dump)
+	  dump("", "");
+#endif
 }
 
 
@@ -944,6 +1121,17 @@
 list_vanquished(defquery, ask)
 int defquery;
 boolean ask;
+#ifdef DUMP_LOG
+{
+  do_vanquished(defquery, ask, FALSE);
+}
+
+void
+do_vanquished(defquery, ask, want_dump)
+int defquery;
+boolean ask;
+boolean want_dump;
+#endif
 {
     register int i, lev;
     int ntypes = 0, max_lev = 0, nkilled;
@@ -971,6 +1159,10 @@
 	    klwin = create_nhwindow(NHW_MENU);
 	    putstr(klwin, 0, "Vanquished creatures:");
 	    putstr(klwin, 0, "");
+#ifdef DUMP_LOG
+	    if (want_dump)
+	      dump("", "Vanquished creatures");
+#endif
 
 	    /* countdown by monster "toughness" */
 	    for (lev = max_lev; lev >= 0; lev--)
@@ -1004,6 +1196,10 @@
 #endif
 		    }
 		    putstr(klwin, 0, buf);
+#ifdef DUMP_LOG
+		    if (want_dump)
+		      dump("  ", buf);
+#endif
 		}
 	    /*
 	     * if (Hallucination)
@@ -1013,9 +1209,17 @@
 		putstr(klwin, 0, "");
 		Sprintf(buf, "%ld creatures vanquished.", total_killed);
 		putstr(klwin, 0, buf);
+#ifdef DUMP_LOG
+		if (want_dump)
+		  dump("  ", buf);
+#endif
 	    }
 	    display_nhwindow(klwin, TRUE);
 	    destroy_nhwindow(klwin);
+#ifdef DUMP_LOG
+	    if (want_dump)
+	      dump("", "");
+#endif
 	}
     }
 }
@@ -1032,10 +1236,18 @@
     return n;
 }
 
+#ifdef DUMP_LOG
+STATIC_OVL void
+list_genocided(defquery, ask, want_dump)
+int defquery;
+boolean ask;
+boolean want_dump;
+#else
 STATIC_OVL void
 list_genocided(defquery, ask)
 int defquery;
 boolean ask;
+#endif
 {
     register int i;
     int ngenocided;
@@ -1055,6 +1267,10 @@
 	    klwin = create_nhwindow(NHW_MENU);
 	    putstr(klwin, 0, "Genocided species:");
 	    putstr(klwin, 0, "");
+#ifdef DUMP_LOG
+	    if (want_dump)
+	      dump("", "Genocided species");
+#endif
 
 	    for (i = LOW_PM; i < NUMMONS; i++)
 		if (mvitals[i].mvflags & G_GENOD) {
@@ -1065,11 +1281,21 @@
 		    else
 			Strcpy(buf, makeplural(mons[i].mname));
 		    putstr(klwin, 0, buf);
+#ifdef DUMP_LOG
+		    if (want_dump)
+		      dump("  ", buf);
+#endif
 		}
 
 	    putstr(klwin, 0, "");
 	    Sprintf(buf, "%d species genocided.", ngenocided);
 	    putstr(klwin, 0, buf);
+#ifdef DUMP_LOG
+	    if (want_dump) {
+	      dump("", buf);
+	      dump("","");
+	    }
+#endif
 
 	    display_nhwindow(klwin, TRUE);
 	    destroy_nhwindow(klwin);
diff -ruN nethack-3.4.0./src/invent.c nethack-3.4.0/src/invent.c
--- nethack-3.4.0./src/invent.c	Thu Apr 11 17:58:28 2002
+++ nethack-3.4.0/src/invent.c	Wed Jun 12 00:29:19 2002
@@ -20,7 +20,11 @@
 STATIC_DCL boolean FDECL(putting_on, (const char *));
 STATIC_PTR int FDECL(ckunpaid,(struct obj *));
 STATIC_PTR int FDECL(ckvalidcat,(struct obj *));
+#ifdef DUMP_LOG
+static char FDECL(display_pickinv, (const char *,BOOLEAN_P, long *, BOOLEAN_P));
+#else
 static char FDECL(display_pickinv, (const char *,BOOLEAN_P, long *));
+#endif
 #ifdef OVLB
 STATIC_DCL boolean FDECL(this_type_only, (struct obj *));
 STATIC_DCL void NDECL(dounpaid);
@@ -962,7 +966,11 @@
 		    if (ilet == '?' && !*lets && *altlets)
 			allowed_choices = altlets;
 		    ilet = display_pickinv(allowed_choices, TRUE,
-					   allowcnt ? &ctmp : (long *)0);
+					   allowcnt ? &ctmp : (long *)0
+#ifdef DUMP_LOG
+					   , FALSE
+#endif
+					   );
 		    if(!ilet) continue;
 		    if (allowcnt && ctmp >= 0) {
 			cnt = ctmp;
@@ -1580,11 +1588,20 @@
  * inventory and return a count as well as a letter. If out_cnt is not null,
  * any count returned from the menu selection is placed here.
  */
+#ifdef DUMP_LOG
+static char
+display_pickinv(lets, want_reply, out_cnt, want_dump)
+register const char *lets;
+boolean want_reply;
+long* out_cnt;
+boolean want_dump;
+#else
 static char
 display_pickinv(lets, want_reply, out_cnt)
 register const char *lets;
 boolean want_reply;
 long* out_cnt;
+#endif
 {
 	struct obj *otmp;
 	char ilet, ret;
@@ -1604,6 +1621,11 @@
 	} else
 	    win = WIN_INVEN;
 
+#ifdef DUMP_LOG
+	if (want_dump)
+	  dump("", "Your inventory");
+#endif
+
 	/*
 	Exit early if no inventory -- but keep going if we are doing
 	a permanent inventory update.  We need to keep going so the
@@ -1621,6 +1643,10 @@
 #else
 	    pline("Not carrying anything.");
 #endif
+#ifdef DUMP_LOG
+	    if (want_dump)
+	      dump("  Not carrying anything",u.ugold ? " except gold." : ".");
+#endif
 	    return 0;
 	}
 
@@ -1637,6 +1663,13 @@
 		    ret = message_menu(lets[0],
 			  want_reply ? PICK_ONE : PICK_NONE,
 			  xprname(otmp, (char *)0, lets[0], TRUE, 0L, 0L));
+#ifdef DUMP_LOG
+		    if (want_dump) {
+		      char letbuf[7];
+		      sprintf(letbuf, "  %c - ", lets[0]);
+		      dump(letbuf, xprname(otmp, (char *)0, lets[0], TRUE, 0L, 0L));
+		    }
+#endif
 		    break;
 		}
 	    }
@@ -1655,12 +1688,23 @@
 				any.a_void = 0;		/* zero */
 				add_menu(win, NO_GLYPH, &any, 0, 0, ATR_INVERSE,
 				    let_to_name(*invlet, FALSE), MENU_UNSELECTED);
+#ifdef DUMP_LOG
+				if (want_dump)
+				  dump("  ", let_to_name(*invlet, FALSE));
+#endif
 				classcount++;
 			    }
 			    any.a_char = ilet;
 			    add_menu(win, obj_to_glyph(otmp),
 					&any, ilet, 0, ATR_NONE, doname(otmp),
 					MENU_UNSELECTED);
+#ifdef DUMP_LOG
+			    if (want_dump) {
+			      char letbuf[7];
+			      sprintf(letbuf, "  %c - ", ilet);
+			      dump(letbuf, doname(otmp));
+			    }
+#endif
 			}
 		}
 	}
@@ -1682,6 +1726,10 @@
 	    free((genericptr_t)selected);
 	} else
 	    ret = !n ? '\0' : '\033';	/* cancelled */
+#ifdef DUMP_LOG
+	if (want_dump)
+	  dump("", "");
+#endif
 
 	return ret;
 }
@@ -1698,9 +1746,24 @@
 register const char *lets;
 boolean want_reply;
 {
-	return display_pickinv(lets, want_reply, (long *)0);
+	return display_pickinv(lets, want_reply, (long *)0
+#ifdef DUMP_LOG
+			       , FALSE
+#endif
+			       );
 }
 
+#ifdef DUMP_LOG
+/* See display_inventory. This is the same thing WITH dumpfile creation */
+char
+dump_inventory(lets, want_reply)
+register const char *lets;
+boolean want_reply;
+{
+  return display_pickinv(lets, want_reply, (long *)0, TRUE);
+}
+#endif
+
 /*
  * Returns the number of unpaid items within the given list.  This includes
  * contained objects.
diff -ruN nethack-3.4.0./src/options.c nethack-3.4.0/src/options.c
--- nethack-3.4.0./src/options.c	Wed Jun 12 00:29:06 2002
+++ nethack-3.4.0/src/options.c	Wed Jun 12 00:29:19 2002
@@ -220,6 +220,14 @@
 						SET_IN_GAME },
 	{ "dogname",  "the name of your (first) dog (e.g., dogname:Fang)",
 						PL_PSIZ, DISP_IN_GAME },
+#ifdef DUMP_LOG
+	{ "dumpfile", "where to dump data (e.g., dumpfile:/tmp/dump.nh)",
+#ifdef DUMP_FN
+						PL_PSIZ, DISP_IN_GAME },
+#else
+						PL_PSIZ, SET_IN_GAME },
+#endif
+#endif
 	{ "dungeon",  "the symbols to use in drawing the dungeon map",
 						MAXDCHARS+1, SET_IN_FILE },
 	{ "effects",  "the symbols to use in drawing special effects",
@@ -1046,6 +1054,19 @@
 		return;
 	}
 
+#ifdef DUMP_LOG
+	fullname = "dumpfile";
+	if (match_optname(opts, fullname, 3, TRUE)) {
+#ifndef DUMP_FN
+		if (negated) bad_negation(fullname, FALSE);
+		else if ((op = string_for_opt(opts, !tfrom_file)) != 0
+			 && strlen(op) > 1)
+		  nmcpy(dump_fn, op, PL_PSIZ);
+#endif
+		return;
+	}
+#endif
+
 	fullname = "horsename";
 	if (match_optname(opts, fullname, 5, TRUE)) {
 		if (negated) bad_negation(fullname, FALSE);
@@ -2524,6 +2545,10 @@
 	}
 	else if (!strcmp(optname, "dogname")) 
 		Sprintf(buf, "%s", dogname[0] ? dogname : none );
+#ifdef DUMP_LOG
+	else if (!strcmp(optname, "dumpfile"))
+		Sprintf(buf, "%s", dump_fn[0] ? dump_fn: none );
+#endif
 	else if (!strcmp(optname, "dungeon"))
 		Sprintf(buf, "%s", to_be_done);
 	else if (!strcmp(optname, "effects"))
diff -ruN nethack-3.4.0./src/topten.c nethack-3.4.0/src/topten.c
--- nethack-3.4.0./src/topten.c	Thu Apr 11 17:58:28 2002
+++ nethack-3.4.0/src/topten.c	Wed Jun 12 00:29:19 2002
@@ -358,6 +358,12 @@
 	      "Since you were in %s mode, the score list will not be checked.",
 		    wizard ? "wizard" : "discover");
 		topten_print(pbuf);
+#ifdef DUMP_LOG
+		if (dump_fn) {
+		  dump("", "");
+		  dump("", pbuf);
+		}
+#endif
 	    }
 	    goto showwin;
 	}
@@ -378,6 +384,10 @@
 	}
 
 	HUP topten_print("");
+#ifdef DUMP_LOG
+	dump("", "");
+	dump("", "");
+#endif
 
 	/* assure minimum number of points */
 	if(t0->points < POINTSMIN) t0->points = 0;
@@ -422,6 +432,10 @@
 				    t1->points);
 			    topten_print(pbuf);
 			    topten_print("");
+#ifdef DUMP_LOG
+			    dump("", pbuf);
+			    dump("", "");
+#endif
 			}
 		    }
 		    if(occ_cnt < 0) {
@@ -453,16 +467,25 @@
 		}
 #endif	/* UPDATE_RECORD_IN_PLACE */
 		if(!done_stopprint) if(rank0 > 0){
-		    if(rank0 <= 10)
+		    if(rank0 <= 10) {
 			topten_print("You made the top ten list!");
-		    else {
+#ifdef DUMP_LOG
+			dump("", "You made the top ten list!");
+#endif
+		    } else {
 			char pbuf[BUFSZ];
 			Sprintf(pbuf,
 			  "You reached the %d%s place on the top %d list.",
 				rank0, ordin(rank0), ENTRYMAX);
 			topten_print(pbuf);
+#ifdef DUMP_LOG
+			dump("", pbuf);
+#endif
 		    }
 		    topten_print("");
+#ifdef DUMP_LOG
+		    dump("", "");
+#endif
 		}
 	}
 	if(rank0 == 0) rank0 = rank1;
@@ -488,8 +511,12 @@
 		)) continue;
 	    if (rank == rank0 - flags.end_around &&
 		    rank0 > flags.end_top + flags.end_around + 1 &&
-		    !flags.end_own)
+		    !flags.end_own) {
 		topten_print("");
+#ifdef DUMP_LOG
+		dump("", "");
+#endif
+	    }
 	    if(rank != rank0)
 		outentry(rank, t1, FALSE);
 	    else if(!rank1)
@@ -547,6 +574,9 @@
 	while(bp < linebuf + COLNO - 9) *bp++ = ' ';
 	Strcpy(bp, "Hp [max]");
 	topten_print(linebuf);
+#ifdef DUMP_LOG
+	dump("", linebuf);
+#endif
 }
 
 /* so>0: standout line; so=0: ordinary line */
@@ -664,8 +694,15 @@
 		while (bp < linebuf + (COLNO-1)) *bp++ = ' ';
 		*bp = 0;
 		topten_print_bold(linebuf);
-	    } else
+#ifdef DUMP_LOG
+		dump("*", linebuf);
+#endif
+	    } else {
 		topten_print(linebuf);
+#ifdef DUMP_LOG
+		dump(" ", linebuf);
+#endif
+	    }
 	    Sprintf(linebuf, "%15s %s", "", linebuf3);
 	    lngr = strlen(linebuf);
 	}
@@ -690,6 +727,9 @@
 	    topten_print_bold(linebuf);
 	} else
 	    topten_print(linebuf);
+#ifdef DUMP_LOG
+	dump(" ", linebuf);
+#endif
 }
 
 STATIC_OVL int
diff -ruN nethack-3.4.0./src/weapon.c nethack-3.4.0/src/weapon.c
--- nethack-3.4.0./src/weapon.c	Thu Apr 11 17:58:28 2002
+++ nethack-3.4.0/src/weapon.c	Wed Jun 12 00:29:19 2002
@@ -9,6 +9,10 @@
  */
 #include "hack.h"
 
+#ifdef DUMP_LOG
+STATIC_DCL int FDECL(enhance_skill, (BOOLEAN_P));
+#endif
+
 /* Categories whose names don't come from OBJ_NAME(objects[type])
  */
 #define PN_BARE_HANDED			(-1)	/* includes martial arts */
@@ -838,6 +842,23 @@
  */
 int
 enhance_weapon_skill()
+#ifdef DUMP_LOG
+{
+	return enhance_skill(FALSE);
+}
+
+void dump_weapon_skill()
+{
+	enhance_skill(TRUE);
+}
+
+int enhance_skill(int want_dump)
+#endif
+/* This is the original enhance_weapon_skill() function slightly modified
+ * to write the skills to the dump file. I added the wrapper functions just
+ * because it looked like the easiest way to add a parameter to the
+ * function call. - Jukka Lahtinen, August 2001
+ */
 {
     int pass, i, n, len, longest,
 	to_advance, eventually_advance, maxxed_cnt;
@@ -847,8 +868,15 @@
     anything any;
     winid win;
     boolean speedy = FALSE;
+#ifdef DUMP_LOG
+    char buf2[BUFSZ];
+    boolean logged;
+#endif
 
 #ifdef WIZARD
+#ifdef DUMP_LOG
+	if (!want_dump)
+#endif
 	if (wizard && yn("Advance skills without practice?") == 'y')
 	    speedy = TRUE;
 #endif
@@ -865,6 +893,11 @@
 		else if (peaked_skill(i)) maxxed_cnt++;
 	    }
 
+#ifdef DUMP_LOG
+	    if (want_dump)
+		dump("","Your skills");
+	    else {
+#endif
 	    win = create_nhwindow(NHW_MENU);
 	    start_menu(win);
 
@@ -892,6 +925,9 @@
 		add_menu(win, NO_GLYPH, &any, 0, 0, ATR_NONE,
 			     "", MENU_UNSELECTED);
 	    }
+#ifdef DUMP_LOG
+	    } /* want_dump or not */
+#endif
 
 	    /* List the skills, making ones that could be advanced
 	       selectable.  List the miscellaneous skills first.
@@ -903,9 +939,27 @@
 		/* Print headings for skill types */
 		any.a_void = 0;
 		if (i == skill_ranges[pass].first)
+#ifdef DUMP_LOG
+		  if (want_dump) {
+		    dump("  ",skill_ranges[pass].name);
+		    logged=FALSE;
+		  } else
+#endif
 		    add_menu(win, NO_GLYPH, &any, 0, 0, ATR_BOLD,
 			     skill_ranges[pass].name, MENU_UNSELECTED);
 
+#ifdef DUMP_LOG
+		if (want_dump) {
+		  if (P_SKILL(i) > P_UNSKILLED) {
+		    Sprintf(buf2,"%-*s [%s]",
+			    longest, P_NAME(i),skill_level_name(i, buf));
+		    dump("    ",buf2);
+		    logged=TRUE;
+		  } else if (i == skill_ranges[pass].last && !logged) {
+		    dump("    ","(none)");
+		  }
+		} else {
+#endif
 		if (P_RESTRICTED(i)) continue;
 		/*
 		 * Sigh, this assumes a monospaced font unless
@@ -949,6 +1003,9 @@
 		any.a_int = can_advance(i, speedy) ? i+1 : 0;
 		add_menu(win, NO_GLYPH, &any, 0, 0, ATR_NONE,
 			 buf, MENU_UNSELECTED);
+#ifdef DUMP_LOG
+		}
+#endif
 	    }
 
 	    Strcpy(buf, (to_advance > 0) ? "Pick a skill to advance:" :
@@ -958,6 +1015,12 @@
 		Sprintf(eos(buf), "  (%d slot%s available)",
 			u.weapon_slots, plur(u.weapon_slots));
 #endif
+#ifdef DUMP_LOG
+	    if (want_dump) {
+	      dump("","");
+	      n=0;
+	    } else {
+#endif
 	    end_menu(win, buf);
 	    n = select_menu(win, to_advance ? PICK_ONE : PICK_NONE, &selected);
 	    destroy_nhwindow(win);
@@ -974,6 +1037,9 @@
 		    }
 		}
 	    }
+#ifdef DUMP_LOG
+	    }
+#endif
 	} while (speedy && n > 0);
 	return 0;
 }
